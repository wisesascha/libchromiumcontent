diff -ruN chrome/browser/process_singleton_posix.cc chrome/browser/process_singleton_posix.cc
--- chrome/browser/process_singleton_posix.cc
+++ chrome/browser/process_singleton_posix.cc
@@ -37,6 +37,7 @@
 // retrieves the process id from the symbol link and kills it by sending
 // SIGKILL. Then the second process starts as normal.

+#define MAC_APP_STORE
 #include "chrome/browser/process_singleton.h"

 #include <errno.h>
@@ -93,6 +94,37 @@
 using content::BrowserThread;

 namespace {
+    // XXX:
+    class SanitizedSocketPath {
+     public:
+      explicit SanitizedSocketPath(const base::FilePath& socket_path)
+          : socket_path_(socket_path) {
+        if (socket_path.value().length() >= arraysize(sockaddr_un::sun_path)) {
+          bool found_current_dir = GetCurrentDirectory(&old_path_);
+          CHECK(found_current_dir) << "Failed to determine the current directory.";
+          changed_directory_ = SetCurrentDirectory(socket_path.DirName());
+          CHECK(changed_directory_) << "Failed to change directory: " <<
+              socket_path.DirName().value();
+        }
+      }
+
+      ~SanitizedSocketPath() {
+        if (changed_directory_)
+          SetCurrentDirectory(old_path_);
+      }
+
+      base::FilePath SocketPath() const {
+        return changed_directory_ ? socket_path_.BaseName() : socket_path_;
+      }
+
+     private:
+      bool changed_directory_ = false;
+      base::FilePath socket_path_;
+      base::FilePath old_path_;
+
+      DISALLOW_COPY_AND_ASSIGN(SanitizedSocketPath);
+    };
+

 // Timeout for the current browser process to respond. 20 seconds should be
 // enough.
@@ -386,13 +418,16 @@
       return false;
     // Now we know the directory was (at that point) created by the profile
     // owner. Try to connect.
-    sockaddr_un addr;
-    SetupSockAddr(socket_target.value(), &addr);
-    int ret = HANDLE_EINTR(connect(socket->fd(),
-                                   reinterpret_cast<sockaddr*>(&addr),
-                                   sizeof(addr)));
-    if (ret != 0)
-      return false;
+    {
+      SanitizedSocketPath sanitized_socket_target(socket_target);
+      sockaddr_un addr;
+      SetupSockAddr(sanitized_socket_target.SocketPath().value(), &addr);
+      int ret = HANDLE_EINTR(connect(socket->fd(),
+                                     reinterpret_cast<sockaddr*>(&addr),
+                                     sizeof(addr)));
+      if (ret != 0)
+        return false;
+    }
     // Check the cookie again. We only link in /tmp, which is sticky, so, if the
     // directory is still correct, it must have been correct in-between when we
     // connected. POSIX, sadly, lacks a connectat().
@@ -405,8 +440,9 @@
   } else if (errno == EINVAL) {
     // It exists, but is not a symlink (or some other error we detect
     // later). Just connect to it directly; this is an older version of Chrome.
+    SanitizedSocketPath sanitized_socket_path(socket_path);
     sockaddr_un addr;
-    SetupSockAddr(socket_path.value(), &addr);
+    SetupSockAddr(sanitized_socket_path.SocketPath().value(), &addr);
     int ret = HANDLE_EINTR(connect(socket->fd(),
                                    reinterpret_cast<sockaddr*>(&addr),
                                    sizeof(addr)));
@@ -983,14 +1019,19 @@
       << "Temp directory mode is not 700: " << std::oct << dir_mode;

   // Setup the socket symlink and the two cookies.
+  #ifndef MAC_APP_STORE
   base::FilePath socket_target_path =
       socket_dir_.path().Append(chrome::kSingletonSocketFilename);
+  #endif
   base::FilePath cookie(GenerateCookie());
   base::FilePath remote_cookie_path =
       socket_dir_.path().Append(chrome::kSingletonCookieFilename);
   UnlinkPath(socket_path_);
   UnlinkPath(cookie_path_);
-  if (!SymlinkPath(socket_target_path, socket_path_) ||
+  if (
+  #ifndef MAC_APP_STORE
+      !SymlinkPath(socket_target_path, socket_path_) ||
+  #endif
       !SymlinkPath(cookie, cookie_path_) ||
       !SymlinkPath(cookie, remote_cookie_path)) {
     // We've already locked things, so we can't have lost the startup race,
@@ -1001,10 +1042,19 @@
     return false;
   }

-  SetupSocket(socket_target_path.value(), &sock, &addr);
+  #ifndef MAC_APP_STORE
+  	SanitizedSocketPath sanitized_socket_target(socket_target_path);
+  #else
+  	SanitizedSocketPath sanitized_socket_target(socket_path_);
+  #endif
+    SetupSocket(sanitized_socket_target.SocketPath().value(), &sock, &addr);

   if (bind(sock, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
-    PLOG(ERROR) << "Failed to bind() " << socket_target_path.value();
+    #ifndef MAC_APP_STORE
+        PLOG(ERROR) << "Failed to bind() " << socket_target_path.value();
+    #else
+        PLOG(ERROR) << "Failed to bind() " << socket_path_.value();
+    #endif
     CloseSocket(sock);
     return false;
   }
diff -ruN chrome/common/chrome_constants.cc chrome/common/chrome_constants.cc
--- chrome/common/chrome_constants.cc
+++ chrome/common/chrome_constants.cc
@@ -7,7 +7,7 @@
 #include "base/files/file_path.h"

 #define FPL FILE_PATH_LITERAL
-
+#define MAC_APP_STORE
 #if defined(OS_MACOSX)
 #define CHROMIUM_PRODUCT_STRING "Chromium"
 #if defined(GOOGLE_CHROME_BUILD)
@@ -176,8 +176,19 @@
 const base::FilePath::CharType kSingletonCookieFilename[] =
     FPL("SingletonCookie");
 const base::FilePath::CharType kSingletonLockFilename[] = FPL("SingletonLock");
-const base::FilePath::CharType kSingletonSocketFilename[] =
-    FPL("SingletonSocket");
+#ifdef MAC_APP_STORE
+// Used to be SingletonSocket but due to length limits of sockets we must peal this down.
+// See: https://code.google.com/p/chromium/issues/detail?id=33097 this is a temporary
+// work around.
+//
+// See: https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man4/unix.4.html
+ const base::FilePath::CharType kSingletonSocketFilename[] =
+    FPL("S");
+#else
+ const base::FilePath::CharType kSingletonSocketFilename[] =
+      FPL("SingletonSocket");
+#endif
+
 const base::FilePath::CharType kSupervisedUserSettingsFilename[] =
     FPL("Managed Mode Settings");
 const base::FilePath::CharType kSyncCredentialsFilename[] =
diff -ruN chromiumcontent/chromiumcontent.gypi chromiumcontent/chromiumcontent.gypi
--- chromiumcontent/chromiumcontent.gypi
+++ chromiumcontent/chromiumcontent.gypi
@@ -3,10 +3,21 @@
     # Enalbe using proprietary codecs.
     'proprietary_codecs': 1,
     'ffmpeg_branding': 'Chrome',
+    # And the gold's flags are not available in system's ld neither.
+    'linux_use_gold_flags': 0,
+    # Make Linux build contain debug symbols, this flag will add '-g' to cflags.
+    'linux_dump_symbols': 1,
+    # The Linux build of libchromiumcontent.so depends on, but doesn't
+    # provide, tcmalloc by default.  Disabling tcmalloc here also prevents
+    # any conflicts when linking to binaries or libraries that don't use
+    # tcmalloc.
+    'linux_use_tcmalloc': 0,
     # Using libc++ requires building for >= 10.7.
     'mac_deployment_target': '10.8',
     # The 10.8 SDK does not work well with C++11.
     'mac_sdk_min': '10.9',
+    # Use OpenSSL.
+    'use_openssl': 1,
     # Use the standard way of linking with msvc runtime.
     'win_use_allocator_shim': 0,
     'win_release_RuntimeLibrary': '2',
@@ -24,25 +35,20 @@
         'enable_hidpi': 1,
         # Use Dbus.
         'use_dbus': 1,
-        # Make Linux build contain debug symbols, this flag will add '-g' to
-        # cflags.
-        'linux_dump_symbols': 1,
-        # The Linux build of libchromiumcontent.so depends on, but doesn't
-        # provide, tcmalloc by default.  Disabling tcmalloc here also prevents
-        # any conflicts when linking to binaries or libraries that don't use
-        # tcmalloc.
-        'linux_use_tcmalloc': 0,
-        # Force using gold linker.
-        'linux_use_bundled_gold': 1,
-        'conditions': [
-          ['target_arch=="arm"', {
-            'arm_version': 7,
-            'arm_float_abi': 'hard',
-          }],
-          ['target_arch=="ia32"', {
-            'sysroot': '<!(cd <(DEPTH) && pwd -P)/chrome/installer/linux/debian_wheezy_i386-sysroot',
-          }],
-        ],
+      }],
+      ['OS=="linux" and target_arch=="arm"', {
+        'arm_version': 7,
+        'arm_float_abi': 'hard',
+        'linux_dump_symbols': 0,
+      }],
+      ['OS=="linux" and host_arch=="x64"', {
+        'linux_use_gold_flags': 1,
+      }],
+      ['OS=="linux" and host_arch=="ia32"', {
+        # Use system installed clang for building.
+        'make_clang_dir': '/usr',
+        'clang': 1,
+        'clang_use_chrome_plugins': 0,
       }],
     ],
   },
@@ -82,10 +88,17 @@
       'U_STATIC_IMPLEMENTATION',
     ],
     'conditions': [
-      ['OS=="linux" and target_arch=="arm"', {
-        # Work around ODR violations.
-        'ldflags!': [
-          '-Wl,--detect-odr-violations',
+      ['OS=="linux" and host_arch=="ia32"', {
+        'cflags!': [
+          # Clang 3.4 doesn't support these flags.
+          '-Wno-absolute-value',
+          '-Wno-inconsistent-missing-override',
+          '-Wno-pointer-bool-conversion',
+          '-Wno-tautological-pointer-compare',
+          '-Wno-unused-local-typedef',
+          '-Wno-unused-local-typedefs',
+          '-Wno-undefined-bool-conversion',
+          '-Wno-tautological-undefined-compare',
         ],
       }],
     ],
diff -ruN content/browser/accessibility/browser_accessibility_cocoa.mm content/browser/accessibility/browser_accessibility_cocoa.mm
--- content/browser/accessibility/browser_accessibility_cocoa.mm
+++ content/browser/accessibility/browser_accessibility_cocoa.mm
@@ -4,6 +4,7 @@

 #include <execinfo.h>

+#define MAC_APP_STORE
 #import "content/browser/accessibility/browser_accessibility_cocoa.h"

 #include <map>
@@ -21,8 +22,12 @@
 // See http://openradar.appspot.com/9896491. This SPI has been tested on 10.5,
 // 10.6, and 10.7. It allows accessibility clients to observe events posted on
 // this object.
-extern "C" void NSAccessibilityUnregisterUniqueIdForUIElement(id element);
-
+#ifndef MAC_APP_STORE
+ // See http://openradar.appspot.com/9896491. This SPI has been tested on 10.5,
+ // 10.6, and 10.7. It allows accessibility clients to observe events posted on
+ // this object.
+ extern "C" void NSAccessibilityUnregisterUniqueIdForUIElement(id element);
+#endif
 using ui::AXNodeData;
 using content::BrowserAccessibility;
 using content::BrowserAccessibilityDelegate;
@@ -139,8 +144,10 @@

 - (void)detach {
   if (browserAccessibility_) {
-    NSAccessibilityUnregisterUniqueIdForUIElement(self);
-    browserAccessibility_ = NULL;
+  #ifndef MAC_APP_STORE
+       NSAccessibilityUnregisterUniqueIdForUIElement(self);
+  #endif
+   browserAccessibility_ = NULL;
   }
 }

diff -ruN content/browser/device_monitor_mac.mm content/browser/device_monitor_mac.mm
--- content/browser/device_monitor_mac.mm
+++ content/browser/device_monitor_mac.mm
@@ -4,7 +4,11 @@

 #include "content/browser/device_monitor_mac.h"

-#import <QTKit/QTKit.h>
+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+ #import <QTKit/QTKit.h>
+#endif
+#import <Foundation/Foundation.h>

 #include <set>

@@ -150,6 +154,7 @@

 QTKitMonitorImpl::QTKitMonitorImpl(content::DeviceMonitorMac* monitor)
     : DeviceMonitorMacImpl(monitor) {
+#ifndef MAC_APP_STORE
   NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
   device_arrival_ =
       [nc addObserverForName:QTCaptureDeviceWasConnectedNotification
@@ -169,25 +174,34 @@
                        queue:nil
                   usingBlock:^(NSNotification* notification) {
                       OnAttributeChanged(notification);}];
+#endif
 }

 QTKitMonitorImpl::~QTKitMonitorImpl() {
+#ifndef MAC_APP_STORE
+
   NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
   [nc removeObserver:device_arrival_];
   [nc removeObserver:device_removal_];
   [nc removeObserver:device_change_];
+ #endif
 }

 void QTKitMonitorImpl::OnAttributeChanged(
     NSNotification* notification) {
+#ifndef MAC_APP_STORE
+
   if ([[[notification userInfo]
          objectForKey:QTCaptureDeviceChangedAttributeKey]
       isEqualToString:QTCaptureDeviceSuspendedAttribute]) {
     OnDeviceChanged();
   }
+ #endif
 }

 void QTKitMonitorImpl::OnDeviceChanged() {
+    #ifndef MAC_APP_STORE
+
   std::vector<DeviceInfo> snapshot_devices;

   NSArray* devices = [QTCaptureDevice inputDevices];
@@ -212,6 +226,7 @@
         DeviceInfo([[device uniqueID] UTF8String], device_type));
   }
   ConsolidateDevicesListAndNotify(snapshot_devices);
+ #endif
 }

 // Forward declaration for use by CrAVFoundationDeviceObserver.
@@ -547,7 +562,9 @@
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "458404 DeviceMonitorMac::StartMonitoring::QTKit"));
     DVLOG(1) << "Monitoring via QTKit";
+    #ifndef MAC_APP_STORE
     device_monitor_impl_.reset(new QTKitMonitorImpl(this));
+    #endif
   }
 }

diff -ruN content/browser/renderer_host/render_widget_host_view_mac.mm content/browser/renderer_host/render_widget_host_view_mac.mm
--- content/browser/renderer_host/render_widget_host_view_mac.mm
+++ content/browser/renderer_host/render_widget_host_view_mac.mm
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
 #include "content/browser/renderer_host/render_widget_host_view_mac.h"

 #import <objc/runtime.h>
@@ -2972,10 +2973,11 @@
 // Since this implementation doesn't have to wait any IPC calls, this doesn't
 // make any key-typing jank. --hbono 7/23/09
 //
-extern "C" {
-extern NSString *NSTextInputReplacementRangeAttributeName;
-}
-
+#ifndef MAC_APP_STORE
+ extern "C" {
+ extern NSString *NSTextInputReplacementRangeAttributeName;
+ }
+#endif
 - (NSArray *)validAttributesForMarkedText {
   // This code is just copied from WebKit except renaming variables.
   if (!validAttributesForMarkedText_) {
@@ -2983,7 +2985,9 @@
         NSUnderlineStyleAttributeName,
         NSUnderlineColorAttributeName,
         NSMarkedClauseSegmentAttributeName,
+        #ifndef MAC_APP_STORE
         NSTextInputReplacementRangeAttributeName,
+        #endif
         nil]);
   }
   return validAttributesForMarkedText_.get();
diff -ruN content/browser/web_contents/web_contents_view_mac.mm content/browser/web_contents/web_contents_view_mac.mm
--- content/browser/web_contents/web_contents_view_mac.mm
+++ content/browser/web_contents/web_contents_view_mac.mm
@@ -594,7 +594,7 @@
     return;

   NSSelectionDirection direction =
-      [[[notification userInfo] objectForKey:kSelectionDirection]
+      (NSSelectionDirection) [[[notification userInfo] objectForKey:kSelectionDirection]
         unsignedIntegerValue];
   if (direction == NSDirectSelection)
     return;
diff -ruN content/common/sandbox_mac.mm content/common/sandbox_mac.mm
--- content/common/sandbox_mac.mm
+++ content/common/sandbox_mac.mm
@@ -39,10 +39,13 @@
 #include "third_party/icu/source/common/unicode/uchar.h"
 #include "ui/base/layout.h"
 #include "ui/gl/gl_surface.h"
+#define MAC_APP_STORE

 extern "C" {
+#ifndef MAC_APP_STORE
 void CGSSetDenyWindowServerConnections(bool);
 void CGSShutdownServerConnections();
+#endif
 };

 namespace content {
@@ -344,8 +347,10 @@
     // 10.8 and higher because doing it on earlier OSes causes layout tests to
     // fail <http://crbug.com/397642#c48>. This may cause two log messages to
     // be printed to the system logger on certain OS versions.
+    #ifndef MAC_APP_STORE
     CGSSetDenyWindowServerConnections(true);
     CGSShutdownServerConnections();
+    #endif
   }
 }

 diff -ruN media/BUILD.gn media/BUILD.gn
 --- media/BUILD.gn
 +++ media/BUILD.gn
 @@ -398,7 +398,6 @@
        "CoreMIDI.framework",
        "CoreVideo.framework",
        "OpenGL.framework",
 -      "QTKit.framework",
      ]
    }

diff -ruN media/media.gyp media/media.gyp
--- media/media.gyp
+++ media/media.gyp
@@ -590,8 +590,6 @@
         'video/capture/mac/video_capture_device_factory_mac.mm',
         'video/capture/mac/video_capture_device_mac.h',
         'video/capture/mac/video_capture_device_mac.mm',
-        'video/capture/mac/video_capture_device_qtkit_mac.h',
-        'video/capture/mac/video_capture_device_qtkit_mac.mm',
         'video/capture/video_capture_device.cc',
         'video/capture/video_capture_device.h',
         'video/capture/video_capture_device_factory.cc',
@@ -968,7 +966,6 @@
               '$(SDKROOT)/System/Library/Frameworks/CoreMIDI.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreVideo.framework',
               '$(SDKROOT)/System/Library/Frameworks/OpenGL.framework',
-              '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
         }],
diff -ruN media/video/capture/mac/video_capture_device_factory_mac.mm media/video/capture/mac/video_capture_device_factory_mac.mm
--- media/video/capture/mac/video_capture_device_factory_mac.mm
+++ media/video/capture/mac/video_capture_device_factory_mac.mm
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#pragma clang diagnostic ignored "-Wunused-function"
+#define MAC_APP_STORE
 #include "media/video/capture/mac/video_capture_device_factory_mac.h"

 #import <IOKit/audio/IOAudioTypes.h>
@@ -51,6 +53,7 @@
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
           "458397 media::EnumerateDevicesUsingQTKit"));

+  #ifndef MAC_APP_STORE
   scoped_ptr<VideoCaptureDevice::Names> device_names(
         new VideoCaptureDevice::Names());
   NSMutableDictionary* capture_devices =
@@ -65,6 +68,9 @@
     device_names->push_back(name);
   }
   return device_names.Pass();
+  #else
+   return scoped_ptr<media::VideoCaptureDevice::Names>();
+  #endif
 }

 static void RunDevicesEnumeratedCallback(
@@ -94,6 +100,7 @@

 scoped_ptr<VideoCaptureDevice> VideoCaptureDeviceFactoryMac::Create(
     const VideoCaptureDevice::Name& device_name) {
+        #ifndef MAC_APP_STORE
   DCHECK(thread_checker_.CalledOnValidThread());
   DCHECK_NE(device_name.capture_api_type(),
             VideoCaptureDevice::Name::API_TYPE_UNKNOWN);
@@ -110,12 +117,16 @@
     }
   }
   return scoped_ptr<VideoCaptureDevice>(capture_device.Pass());
+  #else
+  return scoped_ptr<VideoCaptureDevice>();
+  #endif
 }

 void VideoCaptureDeviceFactoryMac::GetDeviceNames(
     VideoCaptureDevice::Names* device_names) {
   // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/458397 is
   // fixed.
+ #ifndef MAC_APP_STORE
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
           "458397 VideoCaptureDeviceFactoryMac::GetDeviceNames"));
@@ -149,6 +160,7 @@
     // We should not enumerate QTKit devices in Device Thread;
     NOTREACHED();
   }
+  #endif
 }

 void VideoCaptureDeviceFactoryMac::EnumerateDeviceNames(const base::Callback<
diff -ruN media/video/capture/mac/video_capture_device_mac.h media/video/capture/mac/video_capture_device_mac.h
--- media/video/capture/mac/video_capture_device_mac.h
+++ media/video/capture/mac/video_capture_device_mac.h
@@ -7,6 +7,7 @@
 // although namely deprecated in 10.9, and AVFoundation is available in versions
 // 10.7 (Lion) and later.

+#define MAC_APP_STORE
 #ifndef MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
 #define MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_

@@ -21,7 +22,9 @@
 #include "media/base/video_capture_types.h"
 #include "media/video/capture/video_capture_device.h"

+#ifndef MAC_APP_STORE
 @protocol PlatformVideoCapturingMac;
+#endif

 namespace base {
 class SingleThreadTaskRunner;
@@ -105,7 +108,9 @@
   const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
   InternalState state_;

+  #ifndef MAC_APP_STORE
   id<PlatformVideoCapturingMac> capture_device_;
+  #endif

   // Used with Bind and PostTask to ensure that methods aren't called after the
   // VideoCaptureDeviceMac is destroyed.
diff -ruN media/video/capture/mac/video_capture_device_mac.mm media/video/capture/mac/video_capture_device_mac.mm
--- media/video/capture/mac/video_capture_device_mac.mm
+++ media/video/capture/mac/video_capture_device_mac.mm
@@ -1,7 +1,10 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-const-variable"
+#pragma clang diagnostic ignored "-Wunused-function"

+#define MAC_APP_STORE
 #include "media/video/capture/mac/video_capture_device_mac.h"

 #include <IOKit/IOCFPlugIn.h>
@@ -19,7 +22,9 @@
 #import "media/base/mac/avfoundation_glue.h"
 #import "media/video/capture/mac/platform_video_capturing_mac.h"
 #import "media/video/capture/mac/video_capture_device_avfoundation_mac.h"
+#ifndef MAC_APP_STORE
 #import "media/video/capture/mac/video_capture_device_qtkit_mac.h"
+#endif
 #include "ui/gfx/geometry/size.h"

 @implementation DeviceNameAndTransportType
@@ -324,6 +329,7 @@
 }

 const std::string VideoCaptureDevice::Name::GetModel() const {
+    #ifndef MAC_APP_STORE
   // Skip the AVFoundation's not USB nor built-in devices.
   if (capture_api_type() == AVFOUNDATION && transport_type() != USB_OR_BUILT_IN)
     return "";
@@ -340,6 +346,10 @@
   std::string id_product = unique_id_.substr(pid_location, kVidPidSize);

   return id_vendor + ":" + id_product;
+  #else
+  return "";
+  #endif
+
 }

 VideoCaptureDeviceMac::VideoCaptureDeviceMac(const Name& device_name)
@@ -347,7 +357,9 @@
       tried_to_square_pixels_(false),
       task_runner_(base::MessageLoopProxy::current()),
       state_(kNotInitialized),
+      #ifndef MAC_APP_STORE
       capture_device_(nil),
+      #endif
       weak_factory_(this) {
   // Avoid reconfiguring AVFoundation or blacklisted devices.
   final_resolution_selected_ = AVFoundationGlue::IsAVFoundationSupported() ||
@@ -355,13 +367,17 @@
 }

 VideoCaptureDeviceMac::~VideoCaptureDeviceMac() {
+    #ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   [capture_device_ release];
+  #endif
 }

 void VideoCaptureDeviceMac::AllocateAndStart(
     const VideoCaptureParams& params,
     scoped_ptr<VideoCaptureDevice::Client> client) {
+    #ifndef MAC_APP_STORE
+
   DCHECK(task_runner_->BelongsToCurrentThread());
   if (state_ != kIdle) {
     return;
@@ -431,9 +447,11 @@
   }

   state_ = kCapturing;
+  #endif
 }

 void VideoCaptureDeviceMac::StopAndDeAllocate() {
+    #ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK(state_ == kCapturing || state_ == kError) << state_;

@@ -442,10 +460,13 @@
   client_.reset();
   state_ = kIdle;
   tried_to_square_pixels_ = false;
+  #endif
 }

 bool VideoCaptureDeviceMac::Init(
     VideoCaptureDevice::Name::CaptureApiType capture_api_type) {
+   #ifndef MAC_APP_STORE
+
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK_EQ(state_, kNotInitialized);

@@ -461,7 +482,9 @@
     return false;

   state_ = kIdle;
+  #endif
   return true;
+
 }

 void VideoCaptureDeviceMac::ReceiveFrame(
@@ -470,6 +493,7 @@
     const VideoCaptureFormat& frame_format,
     int aspect_numerator,
     int aspect_denominator) {
+        #ifndef MAC_APP_STORE
   // This method is safe to call from a device capture thread, i.e. any thread
   // controlled by QTKit/AVFoundation.
   if (!final_resolution_selected_) {
@@ -544,19 +568,24 @@
                                   frame_format,
                                   0,
                                   base::TimeTicks::Now());
+    #endif
 }

 void VideoCaptureDeviceMac::ReceiveError(const std::string& reason) {
+    #ifndef MAC_APP_STORE
   task_runner_->PostTask(FROM_HERE,
                          base::Bind(&VideoCaptureDeviceMac::SetErrorState,
                                     weak_factory_.GetWeakPtr(),
                                     reason));
+    #endif
 }

 void VideoCaptureDeviceMac::SetErrorState(const std::string& reason) {
+#ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   state_ = kError;
   client_->OnError(reason);
+  #endif
 }

 void VideoCaptureDeviceMac::LogMessage(const std::string& message) {
@@ -566,12 +595,14 @@
 }

 bool VideoCaptureDeviceMac::UpdateCaptureResolution() {
+    #ifndef MAC_APP_STORE
   if (![capture_device_ setCaptureHeight:capture_format_.frame_size.height()
                                    width:capture_format_.frame_size.width()
                                frameRate:capture_format_.frame_rate]) {
     ReceiveError("Could not configure capture device.");
     return false;
   }
+  #endif
   return true;
 }

diff -ruN media/video/capture/mac/video_capture_device_qtkit_mac.h media/video/capture/mac/video_capture_device_qtkit_mac.h
--- media/video/capture/mac/video_capture_device_qtkit_mac.h
+++ media/video/capture/mac/video_capture_device_qtkit_mac.h
@@ -5,6 +5,9 @@
 // VideoCaptureDeviceQTKit implements all QTKit related code for
 // communicating with a QTKit capture device.

+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+
 #ifndef MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_
 #define MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_

@@ -74,3 +77,4 @@
 @end

 #endif  // MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_
+#endif //MAC_APP_STORE
diff -ruN media/video/capture/mac/video_capture_device_qtkit_mac.mm media/video/capture/mac/video_capture_device_qtkit_mac.mm
--- media/video/capture/mac/video_capture_device_qtkit_mac.mm
+++ media/video/capture/mac/video_capture_device_qtkit_mac.mm
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+
 #import "media/video/capture/mac/video_capture_device_qtkit_mac.h"

 #import <QTKit/QTKit.h>
@@ -355,3 +358,4 @@
 }

 @end
+#endif
diff -ruN net/dns/dns_config_service_posix.cc net/dns/dns_config_service_posix.cc
--- net/dns/dns_config_service_posix.cc
+++ net/dns/dns_config_service_posix.cc
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
 #include "net/dns/dns_config_service_posix.h"

 #include <string>
@@ -207,6 +208,11 @@

   bool Watch() {
     bool success = true;
+    #ifndef MAC_APP_STORE
+        // this is disabled for acceptance to the mac app store,
+        // entitlements do not allow watching sensitive file system
+        // data in /etc/
+
     if (!config_watcher_.Watch(base::Bind(&Watcher::OnConfigChanged,
                                           base::Unretained(this)))) {
       LOG(ERROR) << "DNS config watch failed to start.";
@@ -224,6 +230,7 @@
                                 DNS_CONFIG_WATCH_FAILED_TO_START_HOSTS,
                                 DNS_CONFIG_WATCH_MAX);
     }
+    #endif
     return success;
   }

diff -ruN third_party/WebKit/Source/core/layout/LayoutThemeMac.mm third_party/WebKit/Source/core/layout/LayoutThemeMac.mm
--- third_party/WebKit/Source/core/layout/LayoutThemeMac.mm
+++ third_party/WebKit/Source/core/layout/LayoutThemeMac.mm
@@ -145,7 +145,7 @@
 extern "C" {
 void _NSDrawCarbonThemeBezel(NSRect frame, BOOL enabled, BOOL flipped);
 // Request for public API: rdar://13787640
-void _NSDrawCarbonThemeListBox(NSRect frame, BOOL enabled, BOOL flipped, BOOL always_yes);
+// void _NSDrawCarbonThemeListBox(NSRect frame, BOOL enabled, BOOL flipped, BOOL always_yes);
 }

 namespace blink {
@@ -781,7 +781,7 @@
 bool LayoutThemeMac::paintTextArea(LayoutObject* o, const PaintInfo& paintInfo, const IntRect& r)
 {
     LocalCurrentGraphicsContext localContext(paintInfo.context, r);
-    _NSDrawCarbonThemeListBox(r, isEnabled(o) && !isReadOnlyControl(o), YES, YES);
+    // _NSDrawCarbonThemeListBox(r, isEnabled(o) && !isReadOnlyControl(o), YES, YES);
     return false;
 }

@@ -1001,7 +1001,7 @@
     // Now inflate it to account for the shadow.
     IntRect inflatedRect = rect;
     if (rect.height() <= minimumProgressBarHeight(layoutObject->styleRef()))
-        inflatedRect = ThemeMac::inflateRect(inflatedRect, size, progressBarMargins(controlSize), zoomLevel);
+        inflatedRect = ThemeMac::inflateRect(inflatedRect, size, progressBarMargins((NSControlSize) controlSize), zoomLevel);

     LayoutProgress* renderProgress = toLayoutProgress(layoutObject);
     HIThemeTrackDrawInfo trackInfo;
diff -ruN third_party/WebKit/Source/platform/mac/KillRingMac.mm third_party/WebKit/Source/platform/mac/KillRingMac.mm
--- third_party/WebKit/Source/platform/mac/KillRingMac.mm
+++ third_party/WebKit/Source/platform/mac/KillRingMac.mm
@@ -32,12 +32,12 @@

 // Kill ring calls. Would be better to use NSKillRing.h, but that's not available as API or SPI.

-void _NSInitializeKillRing();
-void _NSAppendToKillRing(NSString *);
-void _NSPrependToKillRing(NSString *);
-NSString *_NSYankFromKillRing();
-void _NSNewKillRingSequence();
-void _NSSetKillRingToYankedState();
+// void _NSInitializeKillRing();
+// void _NSAppendToKillRing(NSString *);
+// void _NSPrependToKillRing(NSString *);
+// NSString *_NSYankFromKillRing();
+// void _NSNewKillRingSequence();
+// void _NSSetKillRingToYankedState();

 }

@@ -46,38 +46,39 @@
     static bool initializedKillRing = false;
     if (!initializedKillRing) {
         initializedKillRing = true;
-        _NSInitializeKillRing();
+        // _NSInitializeKillRing();
     }
 }

 void KillRing::append(const String& string)
 {
     initializeKillRingIfNeeded();
-    _NSAppendToKillRing(string);
+    // _NSAppendToKillRing(string);
 }

 void KillRing::prepend(const String& string)
 {
     initializeKillRingIfNeeded();
-    _NSPrependToKillRing(string);
+    // _NSPrependToKillRing(string);
 }

 String KillRing::yank()
 {
     initializeKillRingIfNeeded();
-    return _NSYankFromKillRing();
+    // return _NSYankFromKillRing();
+    return "";
 }

 void KillRing::startNewSequence()
 {
     initializeKillRingIfNeeded();
-    _NSNewKillRingSequence();
+    // _NSNewKillRingSequence();
 }

 void KillRing::setToYankedState()
 {
     initializeKillRingIfNeeded();
-    _NSSetKillRingToYankedState();
+    // _NSSetKillRingToYankedState();
 }

 } // namespace blink
diff -ruN third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm
--- third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm
+++ third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm
@@ -22,6 +22,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
+ #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
+

 #include "config.h"

diff -ruN third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm
--- third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm
+++ third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm
@@ -23,6 +23,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

+#pragma clang diagnostic ignored "-Wenum-compare"
+
 #include "config.h"
 #include "platform/RuntimeEnabledFeatures.h"
 #include "platform/scroll/ScrollbarThemeMacCommon.h"
diff -ruN third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm
--- third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm
+++ third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm
@@ -122,7 +122,7 @@

 int ScrollbarThemeMacOverlayAPI::scrollbarThickness(ScrollbarControlSize controlSize)
 {
-    ScrollbarPainter scrollbarPainter = [NSClassFromString(@"NSScrollerImp") scrollerImpWithStyle:recommendedScrollerStyle() controlSize:controlSize horizontal:NO replacingScrollerImp:nil];
+    ScrollbarPainter scrollbarPainter = [NSClassFromString(@"NSScrollerImp") scrollerImpWithStyle:recommendedScrollerStyle() controlSize:(NSControlSize) controlSize horizontal:NO replacingScrollerImp:nil];
     if (supportsExpandedScrollbars())
         [scrollbarPainter setExpanded:YES];
     return [scrollbarPainter trackBoxWidth];
diff -ruN third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm
--- third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm
+++ third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm
@@ -40,8 +40,6 @@

 namespace blink {

-static_assert(ScrollerStyleLegacy == NSScrollerStyleLegacy, "ScrollerStyleLegacy must match NSScrollerStyleLegacy");
-static_assert(ScrollerStyleOverlay == NSScrollerStyleOverlay, "ScrollerStyleOverlay must match NSScrollerStyleOverlay");

 void WebScrollbarTheme::updateScrollbars(
     float initialButtonDelay, float autoscrollButtonDelay,
@@ -52,7 +50,7 @@
         return;

     static_cast<ScrollbarThemeMacCommon*>(ScrollbarTheme::theme())->preferencesChanged(
-        initialButtonDelay, autoscrollButtonDelay, preferredScrollerStyle, redraw);
+        initialButtonDelay, autoscrollButtonDelay, (NSScrollerStyle) preferredScrollerStyle, redraw);
 }

 } // namespace blink
diff -ruN third_party/crashpad/crashpad/util/mac/mac_util.cc third_party/crashpad/crashpad/util/mac/mac_util.cc
--- third_party/crashpad/crashpad/util/mac/mac_util.cc
+++ third_party/crashpad/crashpad/util/mac/mac_util.cc
@@ -39,16 +39,16 @@
 // Don’t call these functions directly, call them through the
 // TryCFCopy*VersionDictionary() helpers to account for the possibility that
 // they may not be present at runtime.
-CFDictionaryRef _CFCopySystemVersionDictionary() WEAK_IMPORT;
-CFDictionaryRef _CFCopyServerVersionDictionary() WEAK_IMPORT;
+// CFDictionaryRef _CFCopySystemVersionDictionary() WEAK_IMPORT;
+// CFDictionaryRef _CFCopyServerVersionDictionary() WEAK_IMPORT;

 // Don’t use these constants with CFDictionaryGetValue() directly, use them with
 // the TryCFDictionaryGetValue() wrapper to account for the possibility that
 // they may not be present at runtime.
-extern const CFStringRef _kCFSystemVersionProductNameKey WEAK_IMPORT;
-extern const CFStringRef _kCFSystemVersionProductVersionKey WEAK_IMPORT;
-extern const CFStringRef _kCFSystemVersionProductVersionExtraKey WEAK_IMPORT;
-extern const CFStringRef _kCFSystemVersionBuildVersionKey WEAK_IMPORT;
+// extern const CFStringRef _kCFSystemVersionProductNameKey WEAK_IMPORT;
+// extern const CFStringRef _kCFSystemVersionProductVersionKey WEAK_IMPORT;
+// extern const CFStringRef _kCFSystemVersionProductVersionExtraKey WEAK_IMPORT;
+// extern const CFStringRef _kCFSystemVersionBuildVersionKey WEAK_IMPORT;

 #undef WEAK_IMPORT

@@ -96,16 +96,10 @@
 // Helpers for the weak-imported private CoreFoundation internals.

 CFDictionaryRef TryCFCopySystemVersionDictionary() {
-  if (_CFCopySystemVersionDictionary) {
-    return _CFCopySystemVersionDictionary();
-  }
   return nullptr;
 }

 CFDictionaryRef TryCFCopyServerVersionDictionary() {
-  if (_CFCopyServerVersionDictionary) {
-    return _CFCopyServerVersionDictionary();
-  }
   return nullptr;
 }

@@ -210,8 +204,8 @@

   bool success = true;

-  CFStringRef version_cf = base::mac::CFCast<CFStringRef>(
-      TryCFDictionaryGetValue(dictionary, _kCFSystemVersionProductVersionKey));
+  // CFStringRef version_cf = base::mac::CFCast<CFStringRef>(
+  //     TryCFDictionaryGetValue(dictionary, _kCFSystemVersionProductVersionKey));
   std::string version;
   if (!version_cf) {
     LOG(ERROR) << "version_cf not found";
@@ -221,8 +215,8 @@
     success &= StringToVersionNumbers(version, major, minor, bugfix);
   }

-  CFStringRef build_cf = base::mac::CFCast<CFStringRef>(
-      TryCFDictionaryGetValue(dictionary, _kCFSystemVersionBuildVersionKey));
+  // CFStringRef build_cf = base::mac::CFCast<CFStringRef>(
+  //     TryCFDictionaryGetValue(dictionary, _kCFSystemVersionBuildVersionKey));
   if (!build_cf) {
     LOG(ERROR) << "build_cf not found";
     success = false;
@@ -230,8 +224,8 @@
     build->assign(base::SysCFStringRefToUTF8(build_cf));
   }

-  CFStringRef product_cf = base::mac::CFCast<CFStringRef>(
-      TryCFDictionaryGetValue(dictionary, _kCFSystemVersionProductNameKey));
+  // CFStringRef product_cf = base::mac::CFCast<CFStringRef>(
+  //     TryCFDictionaryGetValue(dictionary, _kCFSystemVersionProductNameKey));
   std::string product;
   if (!product_cf) {
     LOG(ERROR) << "product_cf not found";
diff -ruN third_party/webrtc/modules/video_render/BUILD.gn third_party/webrtc/modules/video_render/BUILD.gn
--- third_party/webrtc/modules/video_render/BUILD.gn
+++ third_party/webrtc/modules/video_render/BUILD.gn
@@ -110,7 +110,6 @@

       libs += [
         "CoreVideo.framework",
-        "QTKit.framework",
       ]
     }
     if (is_win) {
diff -ruN tools/gyp/pylib/gyp/MSVSVersion.py tools/gyp/pylib/gyp/MSVSVersion.py
--- tools/gyp/pylib/gyp/MSVSVersion.py
+++ tools/gyp/pylib/gyp/MSVSVersion.py
@@ -77,34 +77,33 @@
     assert target_arch in ('x86', 'x64')
     sdk_dir = os.environ.get('WindowsSDKDir')
     if self.sdk_based and sdk_dir:
-      setenv_cmd = os.path.normpath(os.path.join(sdk_dir, 'Bin/SetEnv.Cmd'))
-      if os.path.isfile(setenv_cmd):
-        return [setenv_cmd, '/' + target_arch]
-
-    # We don't use VC/vcvarsall.bat for x86 because vcvarsall calls
-    # vcvars32, which it can only find if VS??COMNTOOLS is set, which it
-    # isn't always.
-    if target_arch == 'x86':
-      if self.short_name == '2013' and (
-          os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64' or
-          os.environ.get('PROCESSOR_ARCHITEW6432') == 'AMD64'):
-        # VS2013 non-Express has a x64-x86 cross that we want to prefer.
-        return [os.path.normpath(
-           os.path.join(self.path, 'VC/vcvarsall.bat')), 'amd64_x86']
-      # Otherwise, the standard x86 compiler.
-      return [os.path.normpath(
-        os.path.join(self.path, 'Common7/Tools/vsvars32.bat'))]
+      return [os.path.normpath(os.path.join(sdk_dir, 'Bin/SetEnv.Cmd')),
+              '/' + target_arch]
     else:
-      assert target_arch == 'x64'
-      arg = 'x86_amd64'
-      # Use the 64-on-64 compiler if we're not using an express
-      # edition and we're running on a 64bit OS.
-      if self.short_name[-1] != 'e' and (
-          os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64' or
-          os.environ.get('PROCESSOR_ARCHITEW6432') == 'AMD64'):
-        arg = 'amd64'
-      return [os.path.normpath(
-          os.path.join(self.path, 'VC/vcvarsall.bat')), arg]
+      # We don't use VC/vcvarsall.bat for x86 because vcvarsall calls
+      # vcvars32, which it can only find if VS??COMNTOOLS is set, which it
+      # isn't always.
+      if target_arch == 'x86':
+        if self.short_name == '2013' and (
+            os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64' or
+            os.environ.get('PROCESSOR_ARCHITEW6432') == 'AMD64'):
+          # VS2013 non-Express has a x64-x86 cross that we want to prefer.
+          return [os.path.normpath(
+             os.path.join(self.path, 'VC/vcvarsall.bat')), 'amd64_x86']
+        # Otherwise, the standard x86 compiler.
+        return [os.path.normpath(
+          os.path.join(self.path, 'Common7/Tools/vsvars32.bat'))]
+      else:
+        assert target_arch == 'x64'
+        arg = 'x86_amd64'
+        # Use the 64-on-64 compiler if we're not using an express
+        # edition and we're running on a 64bit OS.
+        if self.short_name[-1] != 'e' and (
+            os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64' or
+            os.environ.get('PROCESSOR_ARCHITEW6432') == 'AMD64'):
+          arg = 'amd64'
+        return [os.path.normpath(
+            os.path.join(self.path, 'VC/vcvarsall.bat')), arg]


 def _RegistryQueryBase(sysdir, key, value):
diff -ruN tools/gyp/tools/emacs/testdata/media.gyp tools/gyp/tools/emacs/testdata/media.gyp
--- tools/gyp/tools/emacs/testdata/media.gyp
+++ tools/gyp/tools/emacs/testdata/media.gyp
@@ -438,7 +438,6 @@
               '$(SDKROOT)/System/Library/Frameworks/AudioToolbox.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreAudio.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreVideo.framework',
-              '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
         }],
diff -ruN ui/events/cocoa/events_mac.mm ui/events/cocoa/events_mac.mm
--- ui/events/cocoa/events_mac.mm
+++ ui/events/cocoa/events_mac.mm	2015-07-08 16:12:32.000000000 -0700
@@ -1,7 +1,7 @@
 // Copyright 2014 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wswitch"
 #include "ui/events/event_utils.h"

 #include <Cocoa/Cocoa.h>
diff -ruN ui/gfx/font_fallback_mac.mm ui/gfx/font_fallback_mac.mm
--- ui/gfx/font_fallback_mac.mm
+++ ui/gfx/font_fallback_mac.mm
@@ -1,6 +1,7 @@
 // Copyright 2015 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wreturn-type"

 #include "ui/gfx/font_fallback.h"

@@ -16,29 +17,8 @@
 // CTFontCopyDefaultCascadeListForLanguages() doesn't exist in the 10.6 SDK.
 // There is only the following. It doesn't exist in the public header files,
 // but is an exported symbol so should always link.
-extern "C" CFArrayRef CTFontCopyDefaultCascadeList(CTFontRef font_ref);
+// extern "C" CFArrayRef CTFontCopyDefaultCascadeList(CTFontRef font_ref);

-namespace {
-
-// Wrapper for CTFontCopyDefaultCascadeListForLanguages() which should appear in
-// CoreText.h from 10.8 onwards.
-// TODO(tapted): Delete this wrapper when only 10.8+ is supported.
-CFArrayRef CTFontCopyDefaultCascadeListForLanguagesWrapper(
-    CTFontRef font_ref,
-    CFArrayRef language_pref_list) {
-  typedef CFArrayRef (*MountainLionPrototype)(CTFontRef, CFArrayRef);
-  static const MountainLionPrototype cascade_with_languages_function =
-      reinterpret_cast<MountainLionPrototype>(
-          dlsym(RTLD_DEFAULT, "CTFontCopyDefaultCascadeListForLanguages"));
-  if (cascade_with_languages_function)
-    return cascade_with_languages_function(font_ref, language_pref_list);
-
-  // Fallback to the 10.6 Private API.
-  DCHECK(base::mac::IsOSLionOrEarlier());
-  return CTFontCopyDefaultCascadeList(font_ref);
-}
-
-}  // namespace

 namespace gfx {

@@ -78,7 +58,7 @@
       stringArrayForKey:@"AppleLanguages"];
   CFArrayRef languages_cf = base::mac::NSToCFCast(languages);
   base::ScopedCFTypeRef<CFArrayRef> cascade_list(
-      CTFontCopyDefaultCascadeListForLanguagesWrapper(base_font, languages_cf));
+      CTFontCopyDefaultCascadeListForLanguages(base_font, languages_cf));

   std::vector<std::string> fallback_fonts;

diff -ruN ui/shell_dialogs/select_file_dialog_mac.mm ui/shell_dialogs/select_file_dialog_mac.mm
--- ui/shell_dialogs/select_file_dialog_mac.mm
+++ ui/shell_dialogs/select_file_dialog_mac.mm
@@ -4,6 +4,7 @@

 #include "ui/shell_dialogs/select_file_dialog.h"

+#define MAC_APP_STORE
 #import <Cocoa/Cocoa.h>
 #include <CoreServices/CoreServices.h>

@@ -394,7 +395,9 @@
         index = 1;
       }
     } else {
+        #ifndef MAC_APP_STORE
       CHECK([panel isKindOfClass:[NSOpenPanel class]]);
+      #endif
       NSArray* urls = [static_cast<NSOpenPanel*>(panel) URLs];
       for (NSURL* url in urls)
         if ([url isFileURL])
