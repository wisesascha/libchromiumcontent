diff -ruN chrome/browser/process_singleton_posix.cc chrome/browser/process_singleton_posix.cc
--- chrome/browser/process_singleton_posix.cc	2015-02-25 13:55:44.000000000 -0800
+++ chrome/browser/process_singleton_posix.cc	2015-06-28 23:06:25.000000000 -0700
@@ -37,6 +37,7 @@
 // retrieves the process id from the symbol link and kills it by sending
 // SIGKILL. Then the second process starts as normal.

+#define MAC_APP_STORE
 #include "chrome/browser/process_singleton.h"

 #include <errno.h>
@@ -93,6 +94,37 @@
 using content::BrowserThread;

 namespace {
+    // XXX:
+    class SanitizedSocketPath {
+     public:
+      explicit SanitizedSocketPath(const base::FilePath& socket_path)
+          : socket_path_(socket_path) {
+        if (socket_path.value().length() >= arraysize(sockaddr_un::sun_path)) {
+          bool found_current_dir = GetCurrentDirectory(&old_path_);
+          CHECK(found_current_dir) << "Failed to determine the current directory.";
+          changed_directory_ = SetCurrentDirectory(socket_path.DirName());
+          CHECK(changed_directory_) << "Failed to change directory: " <<
+              socket_path.DirName().value();
+        }
+      }
+
+      ~SanitizedSocketPath() {
+        if (changed_directory_)
+          SetCurrentDirectory(old_path_);
+      }
+
+      base::FilePath SocketPath() const {
+        return changed_directory_ ? socket_path_.BaseName() : socket_path_;
+      }
+
+     private:
+      bool changed_directory_ = false;
+      base::FilePath socket_path_;
+      base::FilePath old_path_;
+
+      DISALLOW_COPY_AND_ASSIGN(SanitizedSocketPath);
+    };
+

 // Timeout for the current browser process to respond. 20 seconds should be
 // enough.
@@ -386,13 +418,16 @@
       return false;
     // Now we know the directory was (at that point) created by the profile
     // owner. Try to connect.
-    sockaddr_un addr;
-    SetupSockAddr(socket_target.value(), &addr);
-    int ret = HANDLE_EINTR(connect(socket->fd(),
-                                   reinterpret_cast<sockaddr*>(&addr),
-                                   sizeof(addr)));
-    if (ret != 0)
-      return false;
+    {
+      SanitizedSocketPath sanitized_socket_target(socket_target);
+      sockaddr_un addr;
+      SetupSockAddr(sanitized_socket_target.SocketPath().value(), &addr);
+      int ret = HANDLE_EINTR(connect(socket->fd(),
+                                     reinterpret_cast<sockaddr*>(&addr),
+                                     sizeof(addr)));
+      if (ret != 0)
+        return false;
+    }
     // Check the cookie again. We only link in /tmp, which is sticky, so, if the
     // directory is still correct, it must have been correct in-between when we
     // connected. POSIX, sadly, lacks a connectat().
@@ -405,8 +440,9 @@
   } else if (errno == EINVAL) {
     // It exists, but is not a symlink (or some other error we detect
     // later). Just connect to it directly; this is an older version of Chrome.
+    SanitizedSocketPath sanitized_socket_path(socket_path);
     sockaddr_un addr;
-    SetupSockAddr(socket_path.value(), &addr);
+    SetupSockAddr(sanitized_socket_path.SocketPath().value(), &addr);
     int ret = HANDLE_EINTR(connect(socket->fd(),
                                    reinterpret_cast<sockaddr*>(&addr),
                                    sizeof(addr)));
@@ -983,14 +1019,19 @@
       << "Temp directory mode is not 700: " << std::oct << dir_mode;

   // Setup the socket symlink and the two cookies.
+  #ifndef MAC_APP_STORE
   base::FilePath socket_target_path =
       socket_dir_.path().Append(chrome::kSingletonSocketFilename);
+  #endif
   base::FilePath cookie(GenerateCookie());
   base::FilePath remote_cookie_path =
       socket_dir_.path().Append(chrome::kSingletonCookieFilename);
   UnlinkPath(socket_path_);
   UnlinkPath(cookie_path_);
-  if (!SymlinkPath(socket_target_path, socket_path_) ||
+  if (
+  #ifndef MAC_APP_STORE
+      !SymlinkPath(socket_target_path, socket_path_) ||
+  #endif
       !SymlinkPath(cookie, cookie_path_) ||
       !SymlinkPath(cookie, remote_cookie_path)) {
     // We've already locked things, so we can't have lost the startup race,
@@ -1001,10 +1042,19 @@
     return false;
   }

-  SetupSocket(socket_target_path.value(), &sock, &addr);
+  #ifndef MAC_APP_STORE
+  	SanitizedSocketPath sanitized_socket_target(socket_target_path);
+  #else
+  	SanitizedSocketPath sanitized_socket_target(socket_path_);
+  #endif
+    SetupSocket(sanitized_socket_target.SocketPath().value(), &sock, &addr);

   if (bind(sock, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
-    PLOG(ERROR) << "Failed to bind() " << socket_target_path.value();
+    #ifndef MAC_APP_STORE
+        PLOG(ERROR) << "Failed to bind() " << socket_target_path.value();
+    #else
+        PLOG(ERROR) << "Failed to bind() " << socket_path_.value();
+    #endif
     CloseSocket(sock);
     return false;
   }
diff -ruN chrome/common/chrome_constants.cc chrome/common/chrome_constants.cc
--- chrome/common/chrome_constants.cc	2015-04-23 11:58:06.000000000 -0700
+++ chrome/common/chrome_constants.cc	2015-06-28 23:08:44.000000000 -0700
@@ -7,7 +7,7 @@
 #include "base/files/file_path.h"

 #define FPL FILE_PATH_LITERAL
-
+#define MAC_APP_STORE
 #if defined(OS_MACOSX)
 #define CHROMIUM_PRODUCT_STRING "Chromium"
 #if defined(GOOGLE_CHROME_BUILD)
@@ -176,8 +176,19 @@
 const base::FilePath::CharType kSingletonCookieFilename[] =
     FPL("SingletonCookie");
 const base::FilePath::CharType kSingletonLockFilename[] = FPL("SingletonLock");
-const base::FilePath::CharType kSingletonSocketFilename[] =
-    FPL("SingletonSocket");
+#ifdef MAC_APP_STORE
+// Used to be SingletonSocket but due to length limits of sockets we must peal this down.
+// See: https://code.google.com/p/chromium/issues/detail?id=33097 this is a temporary
+// work around.
+//
+// See: https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man4/unix.4.html
+ const base::FilePath::CharType kSingletonSocketFilename[] =
+    FPL("S");
+#else
+ const base::FilePath::CharType kSingletonSocketFilename[] =
+      FPL("SingletonSocket");
+#endif
+
 const base::FilePath::CharType kSupervisedUserSettingsFilename[] =
     FPL("Managed Mode Settings");
 const base::FilePath::CharType kSyncCredentialsFilename[] =
diff -ruN content/browser/accessibility/browser_accessibility_cocoa.mm content/browser/accessibility/browser_accessibility_cocoa.mm
--- content/browser/accessibility/browser_accessibility_cocoa.mm	2015-05-21 19:44:08.000000000 -0700
+++ content/browser/accessibility/browser_accessibility_cocoa.mm	2015-06-28 23:10:20.000000000 -0700
@@ -4,6 +4,7 @@

 #include <execinfo.h>

+#define MAC_APP_STORE
 #import "content/browser/accessibility/browser_accessibility_cocoa.h"

 #include <map>
@@ -21,8 +22,12 @@
 // See http://openradar.appspot.com/9896491. This SPI has been tested on 10.5,
 // 10.6, and 10.7. It allows accessibility clients to observe events posted on
 // this object.
-extern "C" void NSAccessibilityUnregisterUniqueIdForUIElement(id element);
-
+#ifndef MAC_APP_STORE
+ // See http://openradar.appspot.com/9896491. This SPI has been tested on 10.5,
+ // 10.6, and 10.7. It allows accessibility clients to observe events posted on
+ // this object.
+ extern "C" void NSAccessibilityUnregisterUniqueIdForUIElement(id element);
+#endif
 using ui::AXNodeData;
 using content::BrowserAccessibility;
 using content::BrowserAccessibilityDelegate;
@@ -139,8 +144,10 @@

 - (void)detach {
   if (browserAccessibility_) {
-    NSAccessibilityUnregisterUniqueIdForUIElement(self);
-    browserAccessibility_ = NULL;
+  #ifndef MAC_APP_STORE
+       NSAccessibilityUnregisterUniqueIdForUIElement(self);
+  #endif
+   browserAccessibility_ = NULL;
   }
 }

diff -ruN content/browser/device_monitor_mac.mm content/browser/device_monitor_mac.mm
--- content/browser/device_monitor_mac.mm	2015-04-23 11:58:11.000000000 -0700
+++ content/browser/device_monitor_mac.mm	2015-06-28 23:13:35.000000000 -0700
@@ -4,7 +4,11 @@

 #include "content/browser/device_monitor_mac.h"

-#import <QTKit/QTKit.h>
+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+ #import <QTKit/QTKit.h>
+#endif
+#import <Foundation/Foundation.h>

 #include <set>

@@ -150,6 +154,7 @@

 QTKitMonitorImpl::QTKitMonitorImpl(content::DeviceMonitorMac* monitor)
     : DeviceMonitorMacImpl(monitor) {
+#ifndef MAC_APP_STORE
   NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
   device_arrival_ =
       [nc addObserverForName:QTCaptureDeviceWasConnectedNotification
@@ -169,25 +174,34 @@
                        queue:nil
                   usingBlock:^(NSNotification* notification) {
                       OnAttributeChanged(notification);}];
+#endif
 }

 QTKitMonitorImpl::~QTKitMonitorImpl() {
+#ifndef MAC_APP_STORE
+
   NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
   [nc removeObserver:device_arrival_];
   [nc removeObserver:device_removal_];
   [nc removeObserver:device_change_];
+ #endif
 }

 void QTKitMonitorImpl::OnAttributeChanged(
     NSNotification* notification) {
+#ifndef MAC_APP_STORE
+
   if ([[[notification userInfo]
          objectForKey:QTCaptureDeviceChangedAttributeKey]
       isEqualToString:QTCaptureDeviceSuspendedAttribute]) {
     OnDeviceChanged();
   }
+ #endif
 }

 void QTKitMonitorImpl::OnDeviceChanged() {
+    #ifndef MAC_APP_STORE
+
   std::vector<DeviceInfo> snapshot_devices;

   NSArray* devices = [QTCaptureDevice inputDevices];
@@ -212,6 +226,7 @@
         DeviceInfo([[device uniqueID] UTF8String], device_type));
   }
   ConsolidateDevicesListAndNotify(snapshot_devices);
+ #endif
 }

 // Forward declaration for use by CrAVFoundationDeviceObserver.
@@ -547,7 +562,9 @@
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "458404 DeviceMonitorMac::StartMonitoring::QTKit"));
     DVLOG(1) << "Monitoring via QTKit";
+    #ifndef MAC_APP_STORE
     device_monitor_impl_.reset(new QTKitMonitorImpl(this));
+    #endif
   }
 }

diff -ruN content/browser/renderer_host/render_widget_host_view_mac.mm content/browser/renderer_host/render_widget_host_view_mac.mm
--- content/browser/renderer_host/render_widget_host_view_mac.mm	2015-05-21 19:44:08.000000000 -0700
+++ content/browser/renderer_host/render_widget_host_view_mac.mm	2015-06-29 08:22:31.000000000 -0700
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
 #include "content/browser/renderer_host/render_widget_host_view_mac.h"

 #import <objc/runtime.h>
@@ -2972,10 +2973,11 @@
 // Since this implementation doesn't have to wait any IPC calls, this doesn't
 // make any key-typing jank. --hbono 7/23/09
 //
-extern "C" {
-extern NSString *NSTextInputReplacementRangeAttributeName;
-}
-
+#ifndef MAC_APP_STORE
+ extern "C" {
+ extern NSString *NSTextInputReplacementRangeAttributeName;
+ }
+#endif
 - (NSArray *)validAttributesForMarkedText {
   // This code is just copied from WebKit except renaming variables.
   if (!validAttributesForMarkedText_) {
@@ -2983,7 +2985,9 @@
         NSUnderlineStyleAttributeName,
         NSUnderlineColorAttributeName,
         NSMarkedClauseSegmentAttributeName,
+        #ifndef MAC_APP_STORE
         NSTextInputReplacementRangeAttributeName,
+        #endif
         nil]);
   }
   return validAttributesForMarkedText_.get();
diff -ruN content/browser/web_contents/web_contents_view_mac.mm content/browser/web_contents/web_contents_view_mac.mm
--- content/browser/web_contents/web_contents_view_mac.mm	2015-04-06 10:59:23.000000000 -0700
+++ content/browser/web_contents/web_contents_view_mac.mm	2015-06-29 11:15:10.000000000 -0700
@@ -594,7 +594,7 @@
     return;

   NSSelectionDirection direction =
-      [[[notification userInfo] objectForKey:kSelectionDirection]
+      (NSSelectionDirection) [[[notification userInfo] objectForKey:kSelectionDirection]
         unsignedIntegerValue];
   if (direction == NSDirectSelection)
     return;
diff -ruN content/common/sandbox_mac.mm content/common/sandbox_mac.mm
--- content/common/sandbox_mac.mm	2015-04-06 10:59:23.000000000 -0700
+++ content/common/sandbox_mac.mm	2015-06-29 08:23:39.000000000 -0700
@@ -39,10 +39,13 @@
 #include "third_party/icu/source/common/unicode/uchar.h"
 #include "ui/base/layout.h"
 #include "ui/gl/gl_surface.h"
+#define MAC_APP_STORE

 extern "C" {
+#ifndef MAC_APP_STORE
 void CGSSetDenyWindowServerConnections(bool);
 void CGSShutdownServerConnections();
+#endif
 };

 namespace content {
@@ -344,8 +347,10 @@
     // 10.8 and higher because doing it on earlier OSes causes layout tests to
     // fail <http://crbug.com/397642#c48>. This may cause two log messages to
     // be printed to the system logger on certain OS versions.
+    #ifndef MAC_APP_STORE
     CGSSetDenyWindowServerConnections(true);
     CGSShutdownServerConnections();
+    #endif
   }
 }

diff -ruN media/BUILD.gn media/BUILD.gn
--- media/BUILD.gn	2015-05-21 19:44:09.000000000 -0700
+++ media/BUILD.gn	2015-06-29 23:46:11.000000000 -0700
@@ -398,7 +398,6 @@
       "CoreMIDI.framework",
       "CoreVideo.framework",
       "OpenGL.framework",
-      "QTKit.framework",
     ]
   }

diff -ruN media/media.gyp media/media.gyp
--- media/media.gyp	2015-05-21 19:44:09.000000000 -0700
+++ media/media.gyp	2015-06-30 00:11:49.000000000 -0700
@@ -590,8 +590,6 @@
         'video/capture/mac/video_capture_device_factory_mac.mm',
         'video/capture/mac/video_capture_device_mac.h',
         'video/capture/mac/video_capture_device_mac.mm',
-        'video/capture/mac/video_capture_device_qtkit_mac.h',
-        'video/capture/mac/video_capture_device_qtkit_mac.mm',
         'video/capture/video_capture_device.cc',
         'video/capture/video_capture_device.h',
         'video/capture/video_capture_device_factory.cc',
@@ -968,7 +966,6 @@
               '$(SDKROOT)/System/Library/Frameworks/CoreMIDI.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreVideo.framework',
               '$(SDKROOT)/System/Library/Frameworks/OpenGL.framework',
-              '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
         }],
diff -ruN media/video/capture/mac/video_capture_device_factory_mac.mm media/video/capture/mac/video_capture_device_factory_mac.mm
--- media/video/capture/mac/video_capture_device_factory_mac.mm	2015-04-06 10:59:31.000000000 -0700
+++ media/video/capture/mac/video_capture_device_factory_mac.mm	2015-06-29 10:19:46.000000000 -0700
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#pragma clang diagnostic ignored "-Wunused-function"
+#define MAC_APP_STORE
 #include "media/video/capture/mac/video_capture_device_factory_mac.h"

 #import <IOKit/audio/IOAudioTypes.h>
@@ -51,6 +53,7 @@
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
           "458397 media::EnumerateDevicesUsingQTKit"));

+  #ifndef MAC_APP_STORE
   scoped_ptr<VideoCaptureDevice::Names> device_names(
         new VideoCaptureDevice::Names());
   NSMutableDictionary* capture_devices =
@@ -65,6 +68,9 @@
     device_names->push_back(name);
   }
   return device_names.Pass();
+  #else
+   return scoped_ptr<media::VideoCaptureDevice::Names>();
+  #endif
 }

 static void RunDevicesEnumeratedCallback(
@@ -94,6 +100,7 @@

 scoped_ptr<VideoCaptureDevice> VideoCaptureDeviceFactoryMac::Create(
     const VideoCaptureDevice::Name& device_name) {
+        #ifndef MAC_APP_STORE
   DCHECK(thread_checker_.CalledOnValidThread());
   DCHECK_NE(device_name.capture_api_type(),
             VideoCaptureDevice::Name::API_TYPE_UNKNOWN);
@@ -110,12 +117,16 @@
     }
   }
   return scoped_ptr<VideoCaptureDevice>(capture_device.Pass());
+  #else
+  return scoped_ptr<VideoCaptureDevice>();
+  #endif
 }

 void VideoCaptureDeviceFactoryMac::GetDeviceNames(
     VideoCaptureDevice::Names* device_names) {
   // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/458397 is
   // fixed.
+ #ifndef MAC_APP_STORE
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
           "458397 VideoCaptureDeviceFactoryMac::GetDeviceNames"));
@@ -149,6 +160,7 @@
     // We should not enumerate QTKit devices in Device Thread;
     NOTREACHED();
   }
+  #endif
 }

 void VideoCaptureDeviceFactoryMac::EnumerateDeviceNames(const base::Callback<
diff -ruN media/video/capture/mac/video_capture_device_mac.h media/video/capture/mac/video_capture_device_mac.h
--- media/video/capture/mac/video_capture_device_mac.h	2015-04-23 11:58:15.000000000 -0700
+++ media/video/capture/mac/video_capture_device_mac.h	2015-06-29 08:59:50.000000000 -0700
@@ -7,6 +7,7 @@
 // although namely deprecated in 10.9, and AVFoundation is available in versions
 // 10.7 (Lion) and later.

+#define MAC_APP_STORE
 #ifndef MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
 #define MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_

@@ -21,7 +22,9 @@
 #include "media/base/video_capture_types.h"
 #include "media/video/capture/video_capture_device.h"

+#ifndef MAC_APP_STORE
 @protocol PlatformVideoCapturingMac;
+#endif

 namespace base {
 class SingleThreadTaskRunner;
@@ -105,7 +108,9 @@
   const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
   InternalState state_;

+  #ifndef MAC_APP_STORE
   id<PlatformVideoCapturingMac> capture_device_;
+  #endif

   // Used with Bind and PostTask to ensure that methods aren't called after the
   // VideoCaptureDeviceMac is destroyed.
diff -ruN media/video/capture/mac/video_capture_device_mac.mm media/video/capture/mac/video_capture_device_mac.mm
--- media/video/capture/mac/video_capture_device_mac.mm	2015-04-23 11:58:15.000000000 -0700
+++ media/video/capture/mac/video_capture_device_mac.mm	2015-06-29 10:18:20.000000000 -0700
@@ -1,7 +1,10 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#pragma clang diagnostic ignored "-Wunused-const-variable"
+#pragma clang diagnostic ignored "-Wunused-function"

+#define MAC_APP_STORE
 #include "media/video/capture/mac/video_capture_device_mac.h"

 #include <IOKit/IOCFPlugIn.h>
@@ -19,7 +22,9 @@
 #import "media/base/mac/avfoundation_glue.h"
 #import "media/video/capture/mac/platform_video_capturing_mac.h"
 #import "media/video/capture/mac/video_capture_device_avfoundation_mac.h"
+#ifndef MAC_APP_STORE
 #import "media/video/capture/mac/video_capture_device_qtkit_mac.h"
+#endif
 #include "ui/gfx/geometry/size.h"

 @implementation DeviceNameAndTransportType
@@ -324,6 +329,7 @@
 }

 const std::string VideoCaptureDevice::Name::GetModel() const {
+    #ifndef MAC_APP_STORE
   // Skip the AVFoundation's not USB nor built-in devices.
   if (capture_api_type() == AVFOUNDATION && transport_type() != USB_OR_BUILT_IN)
     return "";
@@ -340,6 +346,10 @@
   std::string id_product = unique_id_.substr(pid_location, kVidPidSize);

   return id_vendor + ":" + id_product;
+  #else
+  return "";
+  #endif
+
 }

 VideoCaptureDeviceMac::VideoCaptureDeviceMac(const Name& device_name)
@@ -347,7 +357,9 @@
       tried_to_square_pixels_(false),
       task_runner_(base::MessageLoopProxy::current()),
       state_(kNotInitialized),
+      #ifndef MAC_APP_STORE
       capture_device_(nil),
+      #endif
       weak_factory_(this) {
   // Avoid reconfiguring AVFoundation or blacklisted devices.
   final_resolution_selected_ = AVFoundationGlue::IsAVFoundationSupported() ||
@@ -355,13 +367,17 @@
 }

 VideoCaptureDeviceMac::~VideoCaptureDeviceMac() {
+    #ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   [capture_device_ release];
+  #endif
 }

 void VideoCaptureDeviceMac::AllocateAndStart(
     const VideoCaptureParams& params,
     scoped_ptr<VideoCaptureDevice::Client> client) {
+    #ifndef MAC_APP_STORE
+
   DCHECK(task_runner_->BelongsToCurrentThread());
   if (state_ != kIdle) {
     return;
@@ -431,9 +447,11 @@
   }

   state_ = kCapturing;
+  #endif
 }

 void VideoCaptureDeviceMac::StopAndDeAllocate() {
+    #ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK(state_ == kCapturing || state_ == kError) << state_;

@@ -442,10 +460,13 @@
   client_.reset();
   state_ = kIdle;
   tried_to_square_pixels_ = false;
+  #endif
 }

 bool VideoCaptureDeviceMac::Init(
     VideoCaptureDevice::Name::CaptureApiType capture_api_type) {
+   #ifndef MAC_APP_STORE
+
   DCHECK(task_runner_->BelongsToCurrentThread());
   DCHECK_EQ(state_, kNotInitialized);

@@ -461,7 +482,9 @@
     return false;

   state_ = kIdle;
+  #endif
   return true;
+
 }

 void VideoCaptureDeviceMac::ReceiveFrame(
@@ -470,6 +493,7 @@
     const VideoCaptureFormat& frame_format,
     int aspect_numerator,
     int aspect_denominator) {
+        #ifndef MAC_APP_STORE
   // This method is safe to call from a device capture thread, i.e. any thread
   // controlled by QTKit/AVFoundation.
   if (!final_resolution_selected_) {
@@ -544,19 +568,24 @@
                                   frame_format,
                                   0,
                                   base::TimeTicks::Now());
+    #endif
 }

 void VideoCaptureDeviceMac::ReceiveError(const std::string& reason) {
+    #ifndef MAC_APP_STORE
   task_runner_->PostTask(FROM_HERE,
                          base::Bind(&VideoCaptureDeviceMac::SetErrorState,
                                     weak_factory_.GetWeakPtr(),
                                     reason));
+    #endif
 }

 void VideoCaptureDeviceMac::SetErrorState(const std::string& reason) {
+#ifndef MAC_APP_STORE
   DCHECK(task_runner_->BelongsToCurrentThread());
   state_ = kError;
   client_->OnError(reason);
+  #endif
 }

 void VideoCaptureDeviceMac::LogMessage(const std::string& message) {
@@ -566,12 +595,14 @@
 }

 bool VideoCaptureDeviceMac::UpdateCaptureResolution() {
+    #ifndef MAC_APP_STORE
   if (![capture_device_ setCaptureHeight:capture_format_.frame_size.height()
                                    width:capture_format_.frame_size.width()
                                frameRate:capture_format_.frame_rate]) {
     ReceiveError("Could not configure capture device.");
     return false;
   }
+  #endif
   return true;
 }

diff -ruN media/video/capture/mac/video_capture_device_qtkit_mac.h media/video/capture/mac/video_capture_device_qtkit_mac.h
--- media/video/capture/mac/video_capture_device_qtkit_mac.h	2014-10-10 01:10:44.000000000 -0700
+++ media/video/capture/mac/video_capture_device_qtkit_mac.h	2015-06-29 09:17:41.000000000 -0700
@@ -5,6 +5,9 @@
 // VideoCaptureDeviceQTKit implements all QTKit related code for
 // communicating with a QTKit capture device.

+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+
 #ifndef MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_
 #define MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_

@@ -74,3 +77,4 @@
 @end

 #endif  // MEDIA_VIDEO_CAPTURE_MAC_VIDEO_CAPTURE_DEVICE_QTKIT_MAC_H_
+#endif //MAC_APP_STORE
diff -ruN media/video/capture/mac/video_capture_device_qtkit_mac.mm media/video/capture/mac/video_capture_device_qtkit_mac.mm
--- media/video/capture/mac/video_capture_device_qtkit_mac.mm	2015-04-23 11:58:15.000000000 -0700
+++ media/video/capture/mac/video_capture_device_qtkit_mac.mm	2015-06-29 09:18:27.000000000 -0700
@@ -2,6 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
+#ifndef MAC_APP_STORE
+
 #import "media/video/capture/mac/video_capture_device_qtkit_mac.h"

 #import <QTKit/QTKit.h>
@@ -355,3 +358,4 @@
 }

 @end
+#endif
diff -ruN net/dns/dns_config_service_posix.cc net/dns/dns_config_service_posix.cc
--- net/dns/dns_config_service_posix.cc	2015-05-21 19:44:09.000000000 -0700
+++ net/dns/dns_config_service_posix.cc	2015-06-29 10:01:50.000000000 -0700
@@ -2,6 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.

+#define MAC_APP_STORE
 #include "net/dns/dns_config_service_posix.h"

 #include <string>
@@ -207,6 +208,11 @@

   bool Watch() {
     bool success = true;
+    #ifndef MAC_APP_STORE
+        // this is disabled for acceptance to the mac app store,
+        // entitlements do not allow watching sensitive file system
+        // data in /etc/
+
     if (!config_watcher_.Watch(base::Bind(&Watcher::OnConfigChanged,
                                           base::Unretained(this)))) {
       LOG(ERROR) << "DNS config watch failed to start.";
@@ -224,6 +230,7 @@
                                 DNS_CONFIG_WATCH_FAILED_TO_START_HOSTS,
                                 DNS_CONFIG_WATCH_MAX);
     }
+    #endif
     return success;
   }

diff -ruN third_party/WebKit/Source/core/layout/LayoutThemeMac.mm third_party/WebKit/Source/core/layout/LayoutThemeMac.mm
--- third_party/WebKit/Source/core/layout/LayoutThemeMac.mm	2015-04-23 11:58:59.000000000 -0700
+++ third_party/WebKit/Source/core/layout/LayoutThemeMac.mm	2015-06-29 10:55:42.000000000 -0700
@@ -1001,7 +1001,7 @@
     // Now inflate it to account for the shadow.
     IntRect inflatedRect = rect;
     if (rect.height() <= minimumProgressBarHeight(layoutObject->styleRef()))
-        inflatedRect = ThemeMac::inflateRect(inflatedRect, size, progressBarMargins(controlSize), zoomLevel);
+        inflatedRect = ThemeMac::inflateRect(inflatedRect, size, progressBarMargins((NSControlSize) controlSize), zoomLevel);

     LayoutProgress* renderProgress = toLayoutProgress(layoutObject);
     HIThemeTrackDrawInfo trackInfo;
diff -ruN third_party/WebKit/Source/platform/mac/KillRingMac.mm third_party/WebKit/Source/platform/mac/KillRingMac.mm
--- third_party/WebKit/Source/platform/mac/KillRingMac.mm	2014-10-10 01:32:50.000000000 -0700
+++ third_party/WebKit/Source/platform/mac/KillRingMac.mm	2015-06-29 09:43:06.000000000 -0700
@@ -32,12 +32,12 @@

 // Kill ring calls. Would be better to use NSKillRing.h, but that's not available as API or SPI.

-void _NSInitializeKillRing();
-void _NSAppendToKillRing(NSString *);
-void _NSPrependToKillRing(NSString *);
-NSString *_NSYankFromKillRing();
-void _NSNewKillRingSequence();
-void _NSSetKillRingToYankedState();
+// void _NSInitializeKillRing();
+// void _NSAppendToKillRing(NSString *);
+// void _NSPrependToKillRing(NSString *);
+// NSString *_NSYankFromKillRing();
+// void _NSNewKillRingSequence();
+// void _NSSetKillRingToYankedState();

 }

@@ -46,38 +46,39 @@
     static bool initializedKillRing = false;
     if (!initializedKillRing) {
         initializedKillRing = true;
-        _NSInitializeKillRing();
+        // _NSInitializeKillRing();
     }
 }

 void KillRing::append(const String& string)
 {
     initializeKillRingIfNeeded();
-    _NSAppendToKillRing(string);
+    // _NSAppendToKillRing(string);
 }

 void KillRing::prepend(const String& string)
 {
     initializeKillRingIfNeeded();
-    _NSPrependToKillRing(string);
+    // _NSPrependToKillRing(string);
 }

 String KillRing::yank()
 {
     initializeKillRingIfNeeded();
-    return _NSYankFromKillRing();
+    // return _NSYankFromKillRing();
+    return "";
 }

 void KillRing::startNewSequence()
 {
     initializeKillRingIfNeeded();
-    _NSNewKillRingSequence();
+    // _NSNewKillRingSequence();
 }

 void KillRing::setToYankedState()
 {
     initializeKillRingIfNeeded();
-    _NSSetKillRingToYankedState();
+    // _NSSetKillRingToYankedState();
 }

 } // namespace blink
diff -ruN third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm
--- third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm	2015-04-23 11:59:00.000000000 -0700
+++ third_party/WebKit/Source/platform/mac/ScrollAnimatorMac.mm	2015-06-29 10:11:30.000000000 -0700
@@ -22,6 +22,8 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
+ #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
+

 #include "config.h"

diff -ruN third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm
--- third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm	2015-05-21 19:45:15.000000000 -0700
+++ third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacCommon.mm	2015-06-29 11:02:59.000000000 -0700
@@ -23,6 +23,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

+#pragma clang diagnostic ignored "-Wenum-compare"
+
 #include "config.h"
 #include "platform/RuntimeEnabledFeatures.h"
 #include "platform/scroll/ScrollbarThemeMacCommon.h"
diff -ruN third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm
--- third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm	2015-05-21 19:45:15.000000000 -0700
+++ third_party/WebKit/Source/platform/scroll/ScrollbarThemeMacOverlayAPI.mm	2015-06-29 10:30:51.000000000 -0700
@@ -122,7 +122,7 @@

 int ScrollbarThemeMacOverlayAPI::scrollbarThickness(ScrollbarControlSize controlSize)
 {
-    ScrollbarPainter scrollbarPainter = [NSClassFromString(@"NSScrollerImp") scrollerImpWithStyle:recommendedScrollerStyle() controlSize:controlSize horizontal:NO replacingScrollerImp:nil];
+    ScrollbarPainter scrollbarPainter = [NSClassFromString(@"NSScrollerImp") scrollerImpWithStyle:recommendedScrollerStyle() controlSize:(NSControlSize) controlSize horizontal:NO replacingScrollerImp:nil];
     if (supportsExpandedScrollbars())
         [scrollbarPainter setExpanded:YES];
     return [scrollbarPainter trackBoxWidth];
diff -ruN third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm
--- third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm	2015-02-25 13:56:23.000000000 -0800
+++ third_party/WebKit/Source/web/mac/WebScrollbarTheme.mm	2015-06-29 11:04:16.000000000 -0700
@@ -40,8 +40,6 @@

 namespace blink {

-static_assert(ScrollerStyleLegacy == NSScrollerStyleLegacy, "ScrollerStyleLegacy must match NSScrollerStyleLegacy");
-static_assert(ScrollerStyleOverlay == NSScrollerStyleOverlay, "ScrollerStyleOverlay must match NSScrollerStyleOverlay");

 void WebScrollbarTheme::updateScrollbars(
     float initialButtonDelay, float autoscrollButtonDelay,
@@ -52,7 +50,7 @@
         return;

     static_cast<ScrollbarThemeMacCommon*>(ScrollbarTheme::theme())->preferencesChanged(
-        initialButtonDelay, autoscrollButtonDelay, preferredScrollerStyle, redraw);
+        initialButtonDelay, autoscrollButtonDelay, (NSScrollerStyle) preferredScrollerStyle, redraw);
 }

 } // namespace blink
diff -ruN third_party/webrtc/modules/video_render/BUILD.gn third_party/webrtc/modules/video_render/BUILD.gn
--- third_party/webrtc/modules/video_render/BUILD.gn	2015-05-21 19:41:46.000000000 -0700
+++ third_party/webrtc/modules/video_render/BUILD.gn	2015-06-30 21:23:27.000000000 -0700
@@ -110,7 +110,6 @@

       libs += [
         "CoreVideo.framework",
-        "QTKit.framework",
       ]
     }
     if (is_win) {
diff -ruN tools/gyp/tools/emacs/testdata/media.gyp tools/gyp/tools/emacs/testdata/media.gyp
--- tools/gyp/tools/emacs/testdata/media.gyp	2014-10-10 01:14:59.000000000 -0700
+++ tools/gyp/tools/emacs/testdata/media.gyp	2015-06-30 09:23:24.000000000 -0700
@@ -438,7 +438,6 @@
               '$(SDKROOT)/System/Library/Frameworks/AudioToolbox.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreAudio.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreVideo.framework',
-              '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
         }],
diff -ruN ui/events/cocoa/events_mac.mm ui/events/cocoa/events_mac.mm
--- ui/events/cocoa/events_mac.mm	2015-04-23 11:58:20.000000000 -0700
+++ ui/events/cocoa/events_mac.mm	2015-06-29 10:04:26.000000000 -0700
@@ -1,7 +1,7 @@
 // Copyright 2014 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#pragma clang diagnostic ignored "-Wswitch"
 #include "ui/events/event_utils.h"

 #include <Cocoa/Cocoa.h>
diff -ruN ui/shell_dialogs/select_file_dialog_mac.mm ui/shell_dialogs/select_file_dialog_mac.mm
--- ui/shell_dialogs/select_file_dialog_mac.mm	2015-02-25 13:55:54.000000000 -0800
+++ ui/shell_dialogs/select_file_dialog_mac.mm	2015-06-29 09:26:24.000000000 -0700
@@ -4,6 +4,7 @@

 #include "ui/shell_dialogs/select_file_dialog.h"

+#define MAC_APP_STORE
 #import <Cocoa/Cocoa.h>
 #include <CoreServices/CoreServices.h>

@@ -394,7 +395,9 @@
         index = 1;
       }
     } else {
+        #ifndef MAC_APP_STORE
       CHECK([panel isKindOfClass:[NSOpenPanel class]]);
+      #endif
       NSArray* urls = [static_cast<NSOpenPanel*>(panel) URLs];
       for (NSURL* url in urls)
         if ([url isFileURL])
